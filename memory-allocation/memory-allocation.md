# memory allocation

## 实验目的

通过深入理解内存分配管理的三种算法，定义相应的数据结构，编写具体代码。 充分模拟三种算法的实现过程，并通过对比，分析三种算法的优劣。

（1）掌握内存分配FF，BF，WF策略及实现的思路；

（2）掌握内存回收过程及实现思路；

（3）参考给出的代码思路，实现内存的申请、释放的管理程序，调试运行，总结程序设计中出现的问题并找出原因。

## 实验原理

（1）  **首次适应算法**（找第一个满足大小的空闲分区）

该算法从空闲分区链首开始查找，直至找到一个能满足其大小要求的空闲分区为止。然后再按照作业的大小，从该分区中划出一块内存分配给请求者，余下的空闲分区仍留在空闲分区链中。

优点： 该算法倾向于使用内存中低地址部分的空闲区，在高地址部分的空闲区很少被利用，从而保留了高地址部分的大空闲 区。显然为以后到达的大作业分配大的内存空间创造了条件。

缺点：低地址部分不断被划分，留下许多难以利用、很小的空闲区，而每次查找又都从低地址部分开始，会增加查找的开销。

（2） **最佳适应算法**（找最小的满足大小的空闲分区）

该算法总是把既能满足要求，又是最小的空闲分区分配给作业。为了加速查找，该算法要求将 所有的空闲区按其大小排序后，以递增顺序形成一个空白链。这样每次找到的第一个满足要求的空闲区，必然是最优的。孤立地看，该算法似乎是最优的，但事实上并不一定。因为每次分配后剩余的空间一定是最小的，在存储器中将留下许多难以利用的小空闲区。同时每次分配后必须重新排序，这也带来了一定的开销。

优点：每次分配给文件的都是最合适该文件大小的分区。

缺点：内存中留下许多难以利用的小的空闲区。

（3） **最坏适应算法**（找最大的满足大小的空闲分区）

该算法按大小递减的顺序形成空闲区链，分配时直接从空闲区链的第一个空闲区中分配（不能 满足需要则不分配）。很显然，如果第一个空闲分区不能满足，那么再没有空闲分区能满足需要。这种分配方法初看起来不太合理，但它也有很强的直观吸引力：在大空闲区中放入程序后，剩下的空闲区常常也很大，于是还能装下一个较大的新程序。最坏适应算法与最佳适应算法的排序正好相反，它的队列指针总是指向最大的空闲区，在进行分配时，总是从最大的空闲 区开始查寻。该算法克服了最佳适应算法留下的许多小的碎片的不足，但保留大的空闲区的可能性减小了，而且空闲区回收也和最佳适应算法一样复杂。

优点：给文件分配分区后剩下的空闲区不至于太小，产生碎片的几率最小，对中小型文件分配分区操作有利。

缺点：使存储器中缺乏大的空闲区，对大型文件的分区分配不利。

## 程序架构

内存的分配与回收主要涉及到内存分配算法、内存紧缩技术、内存的释放等关键问题，因此本次设计程序时，我采用自顶向下的方法，先决定程序架构，在对每一个函数和算法进行完善和填充。程序顶层功能如下：

1 - Set memory size (default=1024) /*设置内存的大小*/

2 - Select memory allocation algorithm /* 设置当前的分配算法 */

3 - New process /*创建新的进程，主要是获取内存的申请数量*/

4 - Terminate a process /*删除进程，归还分配的存储空间，并删除描述该进程内存分配的节点*/

5 - Display memory usage /* 显示当前内存的使用情况，包括空闲区的情况和已经分配的情况 */

五个功能中，最重要的即为2、3、4，下面对其编程思想进行阐述。

功能2用来设置当前的分配算法，最重要的目标就是按照指定的算法整理内存空闲块链表。其中FF应该将空闲块按照开始地址从小到大排列，BF应该按照空闲块内存从小到大排列，WF应该将空闲块按照内存从大到小排序。

功能3用来创建新进程，就需要从空闲区分配内存，并且将新分配的块加入到已分配链表中。根据当前算法在空闲分区链表中搜索合适空闲分区进行分配，分配时注意以下情况：

（1）找到可满足空闲分区且分配后剩余空间足够大，则分割；

（2）找到可满足空闲分区且但分配后剩余空间比较小，则一起分配；

（3）找不可满足需要的空闲分区但空闲分区之和能满足需要，则采用内存紧缩技术，进行空闲分区的合并，然后再分配；

（4）在成功分配内存后，应保持空闲分区按照相应算法有序；

（5）分配成功则返回1，否则返回-1。

功能4用来删除进程，归还分配的存储空间，并删除描述该进程内存分配的结点。然后将空闲块进行可能的合并，基本策略为：

（1）将新释放的结点插入到空闲分区队列末尾

（2）对空闲链表按照地址有序排列

（3）检查并合并相邻的空闲分区

（4）将空闲链表重新按照当前算法排序

## 程序测试

先给程序设置内存大小为1024：

![文本  描述已自动生成](https://gitee.com/bright_xu/blog-image/raw/master/img/clip_image001.png)

然后设置算法为1——首次适应算法：

![image-20220321201114091](https://gitee.com/bright_xu/blog-image/raw/master/img/image-20220321201114091.png)

然后按顺序分配了四个进程，可以看到程序可以解决内碎片问题，如下图：

![image-20220321201122090](https://gitee.com/bright_xu/blog-image/raw/master/img/image-20220321201122090.png)

杀死进程1和3，可以看到空闲块如下：

![image-20220321201134179](https://gitee.com/bright_xu/blog-image/raw/master/img/image-20220321201134179.png)

为了检查程序是否能解决外碎片问题，也就是内存紧缩功能，现在分配一个大小为350的进程，查看它是否会进行内存紧缩。可以看到程序对内存进行了重新整合，也就是使用了内存紧缩技术。如下图：

![image-20220321201141214](https://gitee.com/bright_xu/blog-image/raw/master/img/image-20220321201141214.png)

经过本例的检查，可以看到所有功能都可以正常运行，程序正确。
