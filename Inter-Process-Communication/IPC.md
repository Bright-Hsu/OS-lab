# IPC

## 实验目的

1. 编程实现进程的创建和软中断通信，通过观察、分析实验现象，深入理解进程及进程在调度执行和内存空间等方面的特点，掌握在POSIX 规范中系统调用的功能和使用。

2. 编程实现进程的管道通信，通过观察、分析实验现象，深入理解进程管道通信的特点，掌握管道通信的同步和互斥机制。

## 实验内容

### 进程的软中断通信

使用系统调用fork()创建两个子进程，再用系统调用signal()让父进程捕捉键盘上发出的中断信号（即按delete键），当父进程接收到这两个软中断的某一个后，父进程用系统调用kill()向两个子进程分别发出整数值为16和17软中断信号，子进程获得对应软中断信号，然后分别输出下列信息后终止：

Child process 1 is killed by parent !! 

Child process 2 is killed by parent !! 

父进程调用wait()函数等待两个子进程终止后，输入以下信息，结束进程执行：

Parent process is killed!! 

多运行几次编写的程序，简略分析出现不同结果的原因。

### 进程的管道通信

先猜想该管道程序的运行结果。分析管道通信是怎样实现同步与互斥的，然后按照注释里的要求把代码补充完整，运行程序。修改程序并运行，体会互斥锁的作用，比较有锁和无锁程序的运行结果，并解释之。

## 实验原理

### 软中断通信

**1、lockf(fd, function, size)用于进程互斥**

**2、int kill(pid, sig)传递中断信号**

（1）pid>0时，核心将信号发送给进程pid。

（2）pid=0时，核心将信号发送给与发送进程同组的所有进程。

（3）pid=-1时，核心将信号发送给所有用户标识符真正等于发送进程的有效用户标识号的进程。

**3、signal(sig,function)**

如果接收到中断信号就作相应处理

其中sig用于指定信号的类型，sig为0则表示没有收到任何信号。function：在该进程中的一个函数地址

  （1）function=1时，进程对sig类信号不予理睬，亦即屏蔽了该类信号；

  （2）function=0时，缺省值，进程在收到sig信号后应终止自己；

  （3）function为非0，非1类整数时，function的值即作为信号处理程序的指针。

**4、wait()和waitpid()**

wait（）会暂时停止进程的执行，直到有信号来到或子进程结束。

waitpid和wait的作用本质上相同，但waitpid多出了两个参数pid和options，

pid：pid>0时，只等待进程ID等于pid的子进程，不管子进程。pid=-1时，等待任何一个子进程退出，没有任何限制，此时waitpid作用同wait。pid=0时，等待同一个进程组中的任何子进程，如果子进程已经加入了别的进程组，waitpid不会对它做任何理睬。pid<-1时，等待一个指定进程组中的任何子进程，这个进程组的ID等于pid的绝对值。

options提供了一些额外的选项来控制waitpid，目前在Linux中只支持WNOHANG和WUNTRACED两个选项，这是两个常数，可以用"|"运算符把它们连接起来使用，比如：ret=waitpid(-1,NULL,WNOHANG | WUNTRACED)。如果我们不想使用它们，也可以把options设为0。

**5、sleep()和pause()**

sleep(n)进程暂停n秒，ctrl+c即SIGINT信号可以使sleep提前结束，继续运行。

pause()会令目前的进程暂停(进入睡眠状态), 直到被信号(signal)所中断.。

**6、alarm()**

alarm()用来设置信号SIGALRM 在经过参数seconds 指定的秒数后传送给目前的进程. 如果参数seconds 为0, 则之前设置的闹钟会被取消, 并将剩下的时间返回。

返回值：返回之前闹钟的剩余秒数, 如果之前未设闹钟则返回0。

可以设置忽略或者不捕获此信号，如果采用默认方式其动作是终止调用该alarm函数的进程。

### 管道通信

为了协调双方的通信，管道机制必须提供以下三方面的协调能力：

（1）互斥，即当一个进程正在对pipe执行读/写操作时，其它(另一)进程必须等待。

（2）同步，指当写(输入)进程把一定数量(如4KB)的数据写入pipe，便去睡眠等待，直到读(输出)进程取走数据后，再把他唤醒。当读进程读一空pipe时，也应睡眠等待，直至写进程将数据写入管道后，才将之唤醒。

（3）确定对方是否存在，只有确定了对方已存在时，才能进行通信。

管道是进程间通信的一种简单易用的方法。管道分为匿名管道和命名管道两种。匿名管道只能用于父子进程之间的通信，它的创建使用系统调用pipe()：

`int pipe(int fd[2]);`

其中的参数fd用于描述管道的两端，其中fd[0]是读端，fd[1]是写端。两个进程分别使用读端和写端，就可以进行通信了。

## 流程图

### 软中断通信

![image-20220318234302832](https://gitee.com/bright_xu/blog-image/raw/master/img/image-20220318234302832.png)

### 管道通信

![image-20220318234403510](https://gitee.com/bright_xu/blog-image/raw/master/img/image-20220318234403510.png)

## 实验过程

**1.** **先猜想一下这个程序的运行结果。然后按照注释里的要求把代码补充完整，运行程序。或者多次运行，并且****Delete/quit,****键后，会出现什么结果？分析原因。**

补全代码后，先不按quit键运行，发现先输出前两行，五秒之后输出了第三行，输出见下图。这说明子进程1和2很快就被杀死，而父进程五秒后才被杀死。

![image-20220318234548767](https://gitee.com/bright_xu/blog-image/raw/master/img/image-20220318234548767.png)

在五秒内按下quit键（也就是Ctrl+\），输出如下。可以看到父进程接受到了中断信号3，而子进程都早已经被杀死因此没有收到中断信号，也就没有机会进入到stop函数中。

![image-20220318234609663](https://gitee.com/bright_xu/blog-image/raw/master/img/image-20220318234609663.png)

但是如果按下中断键（也就是Ctrl+C），会导致父进程被挂起在终端，没有被终止，导致附程序始终在后台运行。输出结果如下：

![image-20220318234632856](https://gitee.com/bright_xu/blog-image/raw/master/img/image-20220318234632856.png)

原因分析：虽然五秒内按下quit键，父进程接受到了中断信号3，但是此时子进程都已经终止，因此kill函数无法起到作用，所以子进程无法接收到中断信号。

**2.** **如果程序运行，界面上显示“****Child process 1 is killed by parent !! Child process 2 is killed by parent !!****”，五秒之后显示“****Parent process is killed !!****”，怎样修改程序使得只有接收到相应的中断信号后再发生跳转，执行输出。**

修改程序，这里我的两个子进程调用的中断信号为SIGUSR1何SIGUSR2，对应的证书分别是10和12。 接下来我在两个子进程中都使用了 while(wait_flag==1)，可以看到子进程只有接收到相应的中断信号才会发生跳转。

不加中断信号3时，五秒之后，才输出下图：

![image-20220318234649888](https://gitee.com/bright_xu/blog-image/raw/master/img/image-20220318234649888.png)

在五秒内按下quit，输出如下，可以看到父进程、子进程1、子进程2这三个进程全部都收到了中断信号3，并且都执行调用了stop函数。

![image-20220318234713516](https://gitee.com/bright_xu/blog-image/raw/master/img/image-20220318234713516.png)

**3.** **将本实验中通信产生的中断通过****14** **号信号值进行闹钟中断，将****signal(3,stop)****当中数字信号变为****2****，体会不同中断的执行样式，从而对软中断机制有一个更好的理解。**

将通信产生的中断通过14 号信号值进行闹钟中断，将signal(3,stop)当中数字信号变为2，改完程序之后，运行程序，五秒后看到输出如下：

![image-20220318234723952](https://gitee.com/bright_xu/blog-image/raw/master/img/image-20220318234723952.png)
